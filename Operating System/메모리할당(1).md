#### Logical and Physical Address
프로그램이 실행되기 위해서는 메모리에 적재되어야 하는데 이때 해당 프로세스만의 독립적인 공간이 생성된다.
이 주소는 논리주소(Logical Address)라고 한다.
각 논리 주소는 0번지 부터 시작하며 프로세스마다 독립적인 공간이 생성된다.

물리적 주소(Physical Address)는 해당 프로세스가 실제로 메모리에 올라가는 주소를 말한다. 하지만 CPU는 물리 주소를 보는 것이 아니라
논리 주소를 보기 떄문에 논리주소와 물리 주소간의 주소의 연결이 필요한데, 이를 **주소 바인딩(Address Binding)** 이라고 한다.

#### Address Binding
주소 바인딩은 일어나는 시기에 따라 3가지로 분류된다.
**1\. Compile Time:** 프로그램을 컴파일 할 때 물리주소가 결정됨. 절대적인 주소를 갖기 때문에 절대코드를 생성하는 방식. 다른 주소로 할당하고 싶으면 다시 컴파일해야하기 때문에 비효율적 
**2\. Load Time:** 프로그램이 실행되면서 주소가 결정되는 방식. 로더에 의해 주소가 부여되고 물리적 주소의 위치는 고정.
**3\. Run Time:** 프로그램 실행 이후에도 메모리 주소의 위치가 변할 수 있는 방식. 그렇기 때문에 주소 매핑 테이블을 이용. 실시간 변동이 가능하기 때문에 MMU, Base Register, Limit Register와 같은 하드웨어의 지원이 필요하다.

#### Memory Management Unit(MMU)
Run Time Binding을 지원하기 위해서는 하드웨어의 지원이 필요하다. CPU는 논리주소만을 읽기 때문에 물리주소와 논리주소 사이의 연결이 필요하다. 프로세스는 각자의 독립적인 공간이 있기 때문에 MMU의 Base Register와 Limit Register를 통해서 물리주소의 위치를 알아낸다.
가령 CPU가 프로세스 P의 346번째 주소를 요구하고 있다면 Base Register는 해당 프로세스 P가 물리메모리의 시작주소를 갖고 있다. 해당 주소에서 CPU가 요구하는 주소(오프셋)을 더하면 실제 물리 주소를 구할 수 있다.

하지만 다중프로그래밍의 환경에서 여러개의 프로세스가 있을 경우에는 프로세스의 크기보다 큰 주소를 요구할 수 있는 상황이 오게 된다. 메모리 보호 차원에서 이러한 일이 발생된다면 시스템에 영향을 미치게 된다. 그렇기 때문에 Limit Register을 통해서 해당 프로세스의 논리주소의 최대값을 담고 있다. 즉, CPU가 요구하는 주소가 Limit Register보다 크다면 트랩을 발생시키게 된다.

#### Phsyical Memory Allocation
프로세스를 물리메모리에 할당하는 방법으로는 **연속할당** 과 **불연속할당**이 있다.
연속할당은 프로세스를 메모리에 연속적으로 통째로 올리는 방식이고 또 다시 **고정분할**과 **가변분할** 방식으로 나뉜다.

**고정분할**: 미리 메모리에 영역을 나누어놓고 프로세스를 할당하는 방식이다. 그렇기 때문에 비효율적이고 **단편화**가 발생한다
**가변분할**: 동적으로 프로그램의 크기에 따라 분할의 크기, 개수 등이 변하는 방식이다. 고정분할보다 효율적이다.
가변분할에서는 프로세스를 메모리에 적재할 때 가용 공간 중 어디에 프로세스를 적재할 것인지에 대한 문제가 있는데 이를 해결하기 위한 3가지 방법이 있다.

프로세스의 사이즈를 n이라고 가정한다면
**1\. First Fit(최초적합)**: 가용 공간중 n이상인 공간 중 가장 첫번째 공간에 프로세스를 적재. 가용공간이 나오면 바로 적재할 수 있기 때문에 시간적으로는 효율적이다.
**2\. Best Fit(최적적합)**: 가용공간이 n이상이면서 최적의 공간에 적재하는 방식이다. 즉 가용공간을 모두 탐색하고 n이상이면서 가장 작은 공간에 적재한다. 공간적인 측면에서는 효율적일 수 있지만 전체를 탐색해야한다는 점에서 많은 오버헤드가 발생한다
**3\. Worst Fit(최악적합)**: 최적적합과 마찬가지로 우선 전체를 탐색해야하기 때문에 오버헤드가 발생한다. 또한 n이상인 가용 공간중에서 가장 큰 곳에 적재하기 때문에 공간적으로 효율적이지 못한다.

연속할당의 문제점으로는 **외부, 내부 단편화**가 발생한다는 점이다. 이는 메모리 공간의 낭비로 이어지기 때문에 공간측면에서는 효율적이지 못하다. 
이런 문제를 해결하기 위해서 **Compacting(압축)** 기법이 있다. 메모리 상에 존재하는 여러 hole들을 재배치하여 큰 공간으로 만드는 방법인데 비용이 많이 드는 작업이고, 오버헤드가 상당히 크기 때문에 현실적으로는 어려운 일이라고 할 수 있다. 
