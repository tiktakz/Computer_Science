#### Race Condition (경쟁상태)

두개 이상의 프로세스 or 스레드가 공유 자원에 대해 concurrent access를 하는 경우 자원을 놓고 경쟁하는 상태이다

#### Critical Section (임계영역)

임계 자원에 접근하여 실행하는 프로그램 코드 부분을 임계 영역이라고 한다. 

공유 데이터에 동시에 서로 다른 프로세스가 들어가는 경우 읽는 경우는 문제가 없지만 값을 수정하는 일의 경우 동기화 문제가 발생할 수 있다.

그렇기 때문에 임계영역에는 한번에 하나의 프로세스만 진입할 수 있게 해야한다.

#### 임계영역이 만족해야하는 조건 3개

1\. **Mutual Exclusion** (상호배제): 하나의 프로세스가 임계영역에서 작업 중이면 다른 프로세스는 임계 영역에 접근하면 안된다

2.**Progress** (진행): 임계영역에 프로세스가 하나도 없다면 적어도 하나의 프로세스는 임계 영역에 접근할 수 있어야 하고 어떤 프로세스가 들어갈 것인지 결정해야한다

3\. **Bound Waiting** (한정대기): 임계영역에 들어간 프로세스가 무한정으로 임계영역을 차지해서는 안된다.

#### 임계영역 문제 해결

**1\. Dekker's Algorithm (데커의 알고리즘)**

```
while(true) {
    flag[i] = true; // 프로세스 i가 임계 구역 진입 시도
    while(flag[j]) { // 프로세스 j가 현재 임계 구역에 있는지 확인
        if(turn == j) { // j가 임계 구역 사용 중이면
            flag[i] = false; // 프로세스 i 진입 취소
            while(turn == j); // turn이 j에서 변경될 때까지 대기 (Busy Wait)
            flag[i] = true; // j turn이 끝나면 재진입 시도
        }
    }
}

// Critical Section

turn = j; // 임계 구역 사용 끝나면 turn을 j로 넘겨준다
flag[i] = false; // flag 값을 false로 바꿔 임계 구역 사용 완료를 알림
```

flag변수 : 어떤 프로세스가 임계영역에 들어갈 것인지 나타냄

turn변수 : 어떤 프로세스가 임계영역에 들어갈 순서인지 나타냄

데커의 알고리즘은 상호 배제의 문제를 해결하지만 progress의 문제를 해결하지 못했다.

또한 turn이 바뀔때까지 계속 확인하며 대기해야하는 'Busy Wait(=spin lock)'이 있다.

2\. Peterson's Algorithm (피터슨 알고리즘)

```
while(true) {
    flag[i] = true; // 프로세스 i가 임계 구역 진입 시도
    turn = j; // 다른 프로세스에게 진입 기회 양보
    while(flag[j] && turn == j) { // 다른 프로세스가 진입 시도하면 대기
    }
}

// Critical Section

flag[i] = false; // flag 값을 false로 바꿔 임계 구역 사용 완료를 알림
```

피터슨 알고리즘은 임계영역의 조건을 모두 해결하는 알고리즘이다.

**3\. TestAndSet(TAS)**

이 방법은 소프트웨어적이 아닌 하드웨어적으로 해결하는 방식이다.

메모리값에 대해 atomic한 연산들만 가능하다는 가정하에 검사와 수정이 가능하면 임계영역의 문제는 해결된다.

프로세스가 임계 영역에 들어가면 lock을 하여 다른 프로세스가 임계영역에 들어오지 못하게 한다.

그렇기 때문에 상호배제의 조건을 만족하고 

프로세스가 임계영역에서 나올 때 자신은 lock을 반납하기 때문에 progress의 조건도 만족하게 된다.

하지만 프로세스가 여러개 대기 중일 때는 무한 대기 문제가 발생할 수 있기 때문에 유한대기의 조건을 해결하지 못했다.

또한 Busy Waiting으로 CPU낭비가 크고, 기아상태와 교착상태가 발생할 가능성이 있다.
